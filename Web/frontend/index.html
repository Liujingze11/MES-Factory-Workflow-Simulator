<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>工厂流程模拟器</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: 'Helvetica Neue', sans-serif;
      margin: 40px;
      background-color: #f9f9f9;
    }

    h1 {
      font-size: 28px;
      margin-bottom: 20px;
    }

    div {
      margin-bottom: 20px;
      background-color: #ffffff;
      padding: 15px 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      display: inline-block;
    }

    select, button {
      font-size: 14px;
      padding: 5px 10px;
      margin-right: 10px;
    }

    button {
      background-color: #f1c40f;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    button:hover {
      background-color: #d4ac0d;
    }

    svg {
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
    }

    text {
      pointer-events: none;
    }
  </style>
</head>

<body>
  <h1>工厂流程模拟器</h1>
  <div>
    起点：
    <select id="start">
      <option value="A60 收货区">A60 收货区</option>
    </select>
    终点：
    <select id="end">
      <option value="生产线">生产线</option>
    </select>
    <button onclick="simulate()">开始模拟</button>
  </div>

  <svg width="1000" height="500" id="flowchart"></svg>

  
  <script>
    // ============================
    // 节点坐标及尺寸信息
    // ============================
    const pos = {
      "A60 收货区": [100, 200],
      "A60 地堆存储区": [300, 200],
      "MSU站点": [500, 200],
      "超市1.0": [700, 120],
      "生产线": [700, 320]
    };

    const nodeSize = {
      width: 100,       // 普通节点宽度
      height: 60,       // 普通节点高度
      bigWidth: 140,    // “生产线”节点宽度
      bigHeight: 80     // “生产线”节点高度
    };

    // ============================
    // 连线关系
    // ============================
    const links = [
      ["A60 收货区", "A60 地堆存储区"],
      ["A60 地堆存储区", "MSU站点"],
      ["MSU站点", "超市1.0"],
      ["MSU站点", "生产线"],
      ["超市1.0", "生产线"]
    ];

    // ============================
    // 计算“从一个矩形节点中心到另一个矩形节点中心”的连线
    // 在边框处出发并在边框处结束
    // ============================
    function computeBorderEndpoints(x1, y1, w1, h1, x2, y2, w2, h2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const absDx = Math.abs(dx);
      const absDy = Math.abs(dy);
      const halfW1 = w1 / 2;
      const halfH1 = h1 / 2;
      const halfW2 = w2 / 2;
      const halfH2 = h2 / 2;

      // 1) 计算源节点与目标节点连线与源节点边框的交点（出发点）
      let tSrc;
      if (absDx * halfH1 > absDy * halfW1) {
        // 先到达水平边框
        tSrc = halfW1 / absDx;
      } else {
        // 先到达垂直边框
        tSrc = halfH1 / absDy;
      }
      const srcX = x1 + dx * tSrc;
      const srcY = y1 + dy * tSrc;

      // 2) 计算目标节点边框的交点（到达点），方向反向
      const dxRev = -dx;
      const dyRev = -dy;
      const absDxRev = absDx;
      const absDyRev = absDy;

      let tDst;
      if (absDxRev * halfH2 > absDyRev * halfW2) {
        // 与目标节点水平边框相交
        tDst = halfW2 / absDxRev;
      } else {
        // 与目标节点垂直边框相交
        tDst = halfH2 / absDyRev;
      }
      const dstX = x2 + dxRev * tDst; // 等于 x2 - dx * tDst
      const dstY = y2 + dyRev * tDst; // 等于 y2 - dy * tDst

      return [
        [srcX, srcY],
        [dstX, dstY]
      ];
    }

    // ============================
    // 绘制整个流程图（节点 + 连线），并高亮 path 中的节点
    // ============================
    function drawFlow(path) {
      const svg = d3.select("#flowchart");
      svg.selectAll("*").remove();

      // 定义箭头 Marker
      svg.append("defs").append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 10)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "gray");

      // 1. 绘制节点
      Object.entries(pos).forEach(([name, [x, y]]) => {
        const isBig = (name === "生产线");
        const width = isBig ? nodeSize.bigWidth : nodeSize.width;
        const height = isBig ? nodeSize.bigHeight : nodeSize.height;

        svg.append("rect")
          .attr("x", x - width / 2)
          .attr("y", y - height / 2)
          .attr("width", width)
          .attr("height", height)
          .attr("fill", path.includes(name) ? "orange" : "lightblue")
          .attr("stroke", "black");

        svg.append("text")
          .attr("x", x)
          .attr("y", y + 5)
          .attr("text-anchor", "middle")
          .attr("font-size", "14px")
          .text(name);
      });

      // 2. 绘制连线（所有情况下都用边框交点来绘制）
      links.forEach(([from, to]) => {
        const [x1, y1] = pos[from];
        const [x2, y2] = pos[to];
        const isBigFrom = (from === "生产线");
        const isBigTo   = (to === "生产线");
        const wFrom = isBigFrom ? nodeSize.bigWidth : nodeSize.width;
        const hFrom = isBigFrom ? nodeSize.bigHeight : nodeSize.height;
        const wTo   = isBigTo   ? nodeSize.bigWidth : nodeSize.width;
        const hTo   = isBigTo   ? nodeSize.bigHeight : nodeSize.height;

        const [p1, p2] = computeBorderEndpoints(x1, y1, wFrom, hFrom, x2, y2, wTo, hTo);

        svg.append("line")
          .attr("x1", p1[0])
          .attr("y1", p1[1])
          .attr("x2", p2[0])
          .attr("y2", p2[1])
          .attr("stroke", "gray")
          .attr("marker-end", "url(#arrow)");
      });
    }

    // ============================
    // 根据 path 返回连续中心坐标对数组：
    // [
    //   [ [x_from, y_from], [x_to, y_to] ],
    //   ...
    // ]
    // ============================
    function getPathCoordinates(path) {
      const coords = [];
      for (let i = 0; i < path.length - 1; i++) {
        const fromCenter = pos[path[i]];
        const toCenter   = pos[path[i + 1]];
        coords.push([fromCenter, toCenter]);
      }
      return coords;
    }

    // ============================
    // 主动画：A60 → A60地堆 → MSU →
    //   【分裂】
    //   支路A：MSU → 超市1.0 → 生产线（无保留红点）
    //   支路B：MSU → 生产线（无保留红点）
    // 所有完成后 1s 后重启循环。
    // ============================
    function animateMaterial(path) {
      const svg = d3.select("#flowchart");

      // 清除之前的所有“moving”和“fixed”圆点（fixed 已无用）
      svg.selectAll("circle.moving").remove();
      svg.selectAll("circle.fixed").remove();

      // 获取整体中心坐标（A60→A60地堆→MSU→超市→生产线）
      const coords = getPathCoordinates(path);
      if (coords.length < 3) return; // 必须至少到 MSU 才能分裂

      // --- 1. 在 A60→A60地堆→MSU 三段创建一个“moving”红点
      const [xA60, yA60]       = pos[path[0]]; // A60
      const [xBuffer, yBuffer] = pos[path[1]]; // A60地堆
      const wA60 = nodeSize.width,  hA60 = nodeSize.height;
      const wBuf = nodeSize.width,  hBuf = nodeSize.height;
      const [[startX, startY], ] = computeBorderEndpoints(xA60, yA60, wA60, hA60, xBuffer, yBuffer, wBuf, hBuf);

      const material = svg.append("circle")
        .attr("class", "moving")
        .attr("r", 8)
        .attr("fill", "red")
        .attr("cx", startX)
        .attr("cy", startY + 40);

      let stepIndex = 0;

      function moveStep() {
        if (stepIndex === 0) {
          // A60地堆 → MSU
          const fromName = path[1];
          const toName   = path[2];
          const [x1, y1] = pos[fromName];
          const [x2, y2] = pos[toName];
          const wFrom = nodeSize.width, hFrom = nodeSize.height;
          const wTo   = nodeSize.width, hTo   = nodeSize.height;
          const [[, ], [dstX, dstY]] =
            computeBorderEndpoints(x1, y1, wFrom, hFrom, x2, y2, wTo, hTo);

          material.transition()
            .duration(800)
            .attr("cx", dstX)
            .attr("cy", dstY + 40)
            .on("end", () => {
              stepIndex = 2; // 到达 MSU，直接分裂
              moveStep();
            });
        }
        else if (stepIndex === 2) {
          // 到达 MSU 后分裂——没有保留原点
          const msuName = path[2];
          const [mx, my] = pos[msuName];
          const wM = nodeSize.width,  hM = nodeSize.height;
          const [px, py] = pos[path[1]]; // A60地堆中心
          const wP = nodeSize.width, hP = nodeSize.height;
          const [, [msuEndX, msuEndY]] =
            computeBorderEndpoints(px, py, wP, hP, mx, my, wM, hM);

          // 移除原“moving”红点
          material.remove();

          // 计数：有两条支路，需要等待它们都结束
          let branchesDone = 0;

          // —— 支路A：MSU → 超市1.0 → 生产线
          const branchA1 = svg.append("circle")
            .attr("class", "moving")
            .attr("r", 8)
            .attr("fill", "red")
            .attr("cx", msuEndX)
            .attr("cy", msuEndY + 40);

          // MSU → 超市1.0
          animateFromBranch(msuName, "超市1.0", branchA1, () => {
            // 超市1.0 → 生产线
            const branchA2 = svg.append("circle")
              .attr("class", "moving")
              .attr("r", 8)
              .attr("fill", "red")
              .attr("cx", pos["超市1.0"][0] === undefined ? msuEndX : computeBorderEndpoints(
                  mx, my, wM, hM,
                  pos["超市1.0"][0], pos["超市1.0"][1], nodeSize.width, nodeSize.height
                )[1][0])
              .attr("cy", pos["超市1.0"][1] === undefined ? msuEndY + 40 : computeBorderEndpoints(
                  mx, my, wM, hM,
                  pos["超市1.0"][0], pos["超市1.0"][1], nodeSize.width, nodeSize.height
                )[1][1] + 40);

            animateFromBranch("超市1.0", "生产线", branchA2, () => {
              // 支路A完成
              branchesDone++;
              if (branchesDone === 2) {
                setTimeout(() => { animateMaterial(path); }, 1000);
              }
            });
          });

          // —— 支路B：MSU → 生产线
          const branchB = svg.append("circle")
            .attr("class", "moving")
            .attr("r", 8)
            .attr("fill", "red")
            .attr("cx", msuEndX)
            .attr("cy", msuEndY + 40);

          animateFromBranch(msuName, "生产线", branchB, () => {
            // 支路B完成
            branchesDone++;
            if (branchesDone === 2) {
              setTimeout(() => { animateMaterial(path); }, 1000);
            }
          });
        }
      }

      // 从 A60 → A60地堆 → MSU 第一步开始
      // 由于第一段 A60→A60地堆 坐标计算与第二段一致，直接在 stepIndex=0 执行“地堆→MSU”的动画即可。
      // 先将红点从 A60→A60地堆
      const [x1_0, y1_0] = pos[path[0]];
      const [x2_0, y2_0] = pos[path[1]];
      const [[, ], [midX, midY]] =
        computeBorderEndpoints(x1_0, y1_0, nodeSize.width, nodeSize.height, x2_0, y2_0, nodeSize.width, nodeSize.height);

      // 将红点直接移动到 A60地堆，再让 transition 在 end 时调用 moveStep
      material.transition()
        .duration(800)
        .attr("cx", midX)
        .attr("cy", midY + 40)
        .on("end", () => {
          moveStep(); // 执行地堆→MSU 并接续分裂
        });
    }

    /**
     * 支路动画函数：让 circleSel 从 startName 节点边框移动到 endName 节点边框，
     * 到达后移除 circleSel 并执行 onEnd 回调。
     */
    function animateFromBranch(startName, endName, circleSel, onEnd) {
      const [x1, y1] = pos[startName];
      const [x2, y2] = pos[endName];
      const isBigFrom = (startName === "生产线");
      const isBigTo   = (endName === "生产线");
      const wFrom = isBigFrom ? nodeSize.bigWidth : nodeSize.width;
      const hFrom = isBigFrom ? nodeSize.bigHeight : nodeSize.height;
      const wTo   = isBigTo   ? nodeSize.bigWidth : nodeSize.width;
      const hTo   = isBigTo   ? nodeSize.bigHeight : nodeSize.height;

      const [[srcX, srcY], [dstX, dstY]] =
        computeBorderEndpoints(x1, y1, wFrom, hFrom, x2, y2, wTo, hTo);

      circleSel.transition()
        .duration(1000)
        .attr("cx", dstX)
        .attr("cy", dstY + 40)
        .on("end", () => {
          circleSel.remove();
          if (onEnd) onEnd();
        });
    }

    // ============================
    // 发起与后端的请求，绘制流程并启动动画
    // ============================
    function simulate() {
      const start = document.getElementById("start").value;
      const end   = document.getElementById("end").value;

      fetch("http://127.0.0.1:5000/simulate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ start, end })
      })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            drawFlow(data.path);
            animateMaterial(data.path);
          } else {
            alert("未找到路径！");
          }
        });
    }
  </script>
</body>
</html>
