<!-- 
  工厂流程模拟器 - 物料图
  功能：模拟工厂物料从起点到终点的流动过程
  作者：刘竞泽
  日期：2025.06.09
  版本：1.0
-->


<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>工厂流程模拟器</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
<style>
    /* 页面基础样式 */
    body {
      font-family: 'Helvetica Neue', sans-serif;
      margin: 40px;
      background-color: #f9f9f9;
    }

    /* 主标题样式 */
    h1 {
      font-size: 28px;
      margin-bottom: 20px;
    }

    /* 控制面板容器样式 */
    div {
      margin-bottom: 20px;
      background-color: #ffffff;
      padding: 15px 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      display: inline-block;
    }

    /* 下拉选择框和按钮共用样式 */
    select, button {
      font-size: 14px;
      padding: 5px 10px;
      margin-right: 10px;
    }

    /* 按钮特殊样式 */
    button {
      background-color: #f1c40f;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    /* 按钮悬停效果 */
    button:hover {
      background-color: #d4ac0d;
    }

    /* SVG 画布样式 */
    svg {
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
    }

    /* 文本元素样式（防止事件干扰） */
    text {
      pointer-events: none;
    }
  </style>
</head>


<body>
  <!--起点终点 选择框  -->
  <h1>工厂流程模拟器</h1>
  <div>
    起点：
    <select id="start">
      <option value="A60 收货区">A60 收货区</option>
      <option value="A70 收货区">A70 收货区</option>
    </select>

    <select id="end">
      <option value="生产线">生产线</option>
      <option value="大件立体库">大件立体库</option>
      <option value="立体库上架缓存区">立体库上架缓存区</option>
      <option value="A70 地堆存储区">A70 地堆存储区</option>
    </select>
    <button onclick="simulate()">开始模拟</button>
  </div>

  <svg width="1400" height="800" id="flowchart"></svg>

  <script>
    // 定义各节点在SVG中的坐标位置
    const pos = {
      "A70 收货区": [150, 100],
      "A70 转包区": [400, 100],
      "A70 转运": [700, 100],
      "大件立体库": [1000, 40],
      "立体库上架缓存区": [1000, 100],
      "A70 地堆存储区": [1000, 160],
      "A60 收货区": [150, 300],
      "A60 地堆存储区": [400, 300],
      "MSU站点": [700, 300],
      "超市1.0": [1000, 220],
      "生产线": [1200, 500]
    };

    // 定义节点的大小（普通节点和大节点）
    const nodeSize = {
      width: 100,     // 普通节点宽度
      height: 60,     // 普通节点高度
      bigWidth: 140,  // 大节点宽度（如生产线）
      bigHeight: 80   // 大节点高度
    };
  
    // 定义节点之间的连接关系
    const links = [
      ["A70 收货区", "A70 转包区"],
      ["A70 转包区", "A70 转运"],
      ["A70 转运", "大件立体库"],
      ["A70 转运", "立体库上架缓存区"],
      ["A70 转运", "A70 地堆存储区"],
      ["A60 收货区", "A60 地堆存储区"],
      ["A60 地堆存储区", "MSU站点"],
      ["MSU站点", "超市1.0"],
      ["MSU站点", "生产线"],
      ["超市1.0", "生产线"]
    ];

      /**
   * 计算两个节点之间连接线的起点和终点坐标
   * @param {number} x1 - 起点节点x坐标
   * @param {number} y1 - 起点节点y坐标
   * @param {number} w1 - 起点节点宽度
   * @param {number} h1 - 起点节点高度
   * @param {number} x2 - 终点节点x坐标
   * @param {number} y2 - 终点节点y坐标
   * @param {number} w2 - 终点节点宽度
   * @param {number} h2 - 终点节点高度
   * @return {Array} 包含起点和终点坐标的数组 [[srcX, srcY], [dstX, dstY]]
   */
    function computeBorderEndpoints(x1, y1, w1, h1, x2, y2, w2, h2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const absDx = Math.abs(dx);
      const absDy = Math.abs(dy);
      const halfW1 = w1 / 2;
      const halfH1 = h1 / 2;
      const halfW2 = w2 / 2;
      const halfH2 = h2 / 2;

      let tSrc = absDx * halfH1 > absDy * halfW1 ? halfW1 / absDx : halfH1 / absDy;
      const srcX = x1 + dx * tSrc;
      const srcY = y1 + dy * tSrc;

      let tDst = absDx * halfH2 > absDy * halfW2 ? halfW2 / absDx : halfH2 / absDy;
      const dstX = x2 - dx * tDst;
      const dstY = y2 - dy * tDst;

      return [[srcX, srcY], [dstX, dstY]];
    }

    /**
    * 使用D3.js绘制流程图，并高亮显示指定路径
    * @param {Array} path - 需要高亮的节点名称数组（如：["节点A", "节点B"]）
    */
    function drawFlow(path) {
    // 1. 初始化SVG画布
      const svg = d3.select("#flowchart"); // 选择ID为flowchart的SVG元素
      svg.selectAll("*").remove(); // 清空画布（移除所有现有元素）

      // 2. 设置缩放行为
      const zoom = d3.zoom().on("zoom", (event) => {
        g.attr("transform", event.transform);// 缩放时更新group的transform属性
      });
      svg.call(zoom);// 将缩放行为绑定到SVG上

      const g = svg.append("g");

      // 4. 定义箭头标记（用于连线末端）
      g.append("defs").append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 10)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "gray");

        // 5. 绘制所有节点
      Object.entries(pos).forEach(([name, [x, y]]) => {
        const isBig = name === "生产线";
        const width = isBig ? nodeSize.bigWidth : nodeSize.width;
        const height = isBig ? nodeSize.bigHeight : nodeSize.height;

        g.append("rect")
          .attr("x", x - width / 2)
          .attr("y", y - height / 2)
          .attr("width", width)
          .attr("height", height)
          .attr("fill", path.includes(name) ? "orange" : "lightblue")
          .attr("stroke", "black");

        g.append("text")
          .attr("x", x)
          .attr("y", y + 5)
          .attr("text-anchor", "middle")
          .attr("font-size", "14px")
          .text(name);
      });

      links.forEach(([from, to]) => {
        const [x1, y1] = pos[from];
        const [x2, y2] = pos[to];
        const w1 = from === "生产线" ? nodeSize.bigWidth : nodeSize.width;
        const h1 = from === "生产线" ? nodeSize.bigHeight : nodeSize.height;
        const w2 = to === "生产线" ? nodeSize.bigWidth : nodeSize.width;
        const h2 = to === "生产线" ? nodeSize.bigHeight : nodeSize.height;

        const [p1, p2] = computeBorderEndpoints(x1, y1, w1, h1, x2, y2, w2, h2);

        g.append("line")
          .attr("x1", p1[0])
          .attr("y1", p1[1])
          .attr("x2", p2[0])
          .attr("y2", p2[1])
          .attr("stroke", "gray")
          .attr("marker-end", "url(#arrow)");
      });
    }


// 5. 创建表示物料的圆形（红色小球）
    function animateMaterial(path) {
      const svg = d3.select("#flowchart");
      const g = svg.select("g");

      g.selectAll("circle.moving").remove();

      if (path.length < 2) return;

      let stepIndex = 0;

      const material = g.append("circle")
        .attr("class", "moving")
        .attr("r", 8)
        .attr("fill", "red")
        .attr("cx", pos[path[0]][0])
        .attr("cy", pos[path[0]][1] + 40);


      // 5. 辅助函数：移动到下一个节点
      function moveToNext() {
        if (stepIndex >= path.length - 1) return;

        const from = path[stepIndex];
        const to = path[stepIndex + 1];

        const [x1, y1] = pos[from];
        const [x2, y2] = pos[to];
        const w1 = from === "生产线" ? nodeSize.bigWidth : nodeSize.width;
        const h1 = from === "生产线" ? nodeSize.bigHeight : nodeSize.height;
        const w2 = to === "生产线" ? nodeSize.bigWidth : nodeSize.width;
        const h2 = to === "生产线" ? nodeSize.bigHeight : nodeSize.height;

        const [p1, p2] = computeBorderEndpoints(x1, y1, w1, h1, x2, y2, w2, h2);

        material.transition()
          .duration(800)
          .attr("cx", p2[0])
          .attr("cy", p2[1] + 40)
          .on("end", () => {
            stepIndex++;
            const current = path[stepIndex];

            if (current === "MSU站点") {
              material.remove();
              splitMSU();
            } else if (current === "A70 转运") {
              material.remove();
              splitA70();
            } else {
              // 开始动画
              moveToNext();
            }
          });
      }

      // 处理MSU站点的分流动画(分两条路径：到超市1.0和生产线)
      function splitMSU() {
        const [mx, my] = pos["MSU站点"];
        let done = 0;

        const branchA1 = g.append("circle")
          .attr("class", "moving")
          .attr("r", 8)
          .attr("fill", "red")
          .attr("cx", mx)
          .attr("cy", my + 40);

        animateFromBranch("MSU站点", "超市1.0", branchA1, () => {
          const [sx, sy] = pos["超市1.0"];
          const branchA2 = g.append("circle")
            .attr("class", "moving")
            .attr("r", 8)
            .attr("fill", "red")
            .attr("cx", sx)
            .attr("cy", sy + 40);
          animateFromBranch("超市1.0", "生产线", branchA2, finish);
        });

        const branchB = g.append("circle")
          .attr("class", "moving")
          .attr("r", 8)
          .attr("fill", "red")
          .attr("cx", mx)
          .attr("cy", my + 40);

        animateFromBranch("MSU站点", "生产线", branchB, finish);


        function finish() {
          done++;
          if (done === 2) setTimeout(() => animateMaterial(path), 1000);
        }
      }

      // 处理A70转运的分流动画(分三条路径)
      function splitA70() {
        const [tx, ty] = pos["A70 转运"];
        const targets = ["大件立体库", "立体库上架缓存区", "A70 地堆存储区"];
        let done = 0;

        targets.forEach(target => {
          const circle = g.append("circle")
            .attr("class", "moving")
            .attr("r", 8)
            .attr("fill", "red")
            .attr("cx", tx)
            .attr("cy", ty + 40);

          animateFromBranch("A70 转运", target, circle, () => {
            done++;
            if (done === 3) setTimeout(() => animateMaterial(path), 1000);
          });
        });
      }

      moveToNext();
    }

    // 处理从分支节点开始的动画
    function animateFromBranch(start, end, circleSel, onEnd) {
      const [x1, y1] = pos[start];
      const [x2, y2] = pos[end];
      const w1 = start === "生产线" ? nodeSize.bigWidth : nodeSize.width;
      const h1 = start === "生产线" ? nodeSize.bigHeight : nodeSize.height;
      const w2 = end === "生产线" ? nodeSize.bigWidth : nodeSize.width;
      const h2 = end === "生产线" ? nodeSize.bigHeight : nodeSize.height;

      const [[srcX, srcY], [dstX, dstY]] = computeBorderEndpoints(x1, y1, w1, h1, x2, y2, w2, h2);

      circleSel.transition()
        .duration(1000)
        .attr("cx", dstX)
        .attr("cy", dstY + 40)
        .on("end", () => {
          circleSel.remove();
          if (onEnd) onEnd();
        });
    }

    // 主模拟函数，处理用户交互
  function simulate() {
      const start = document.getElementById("start").value;
      const end = document.getElementById("end").value;

      fetch("http://127.0.0.1:5000/simulate", {
        method: "POST",  // 确保这里是 POST
        headers: { 
          "Content-Type": "application/json"  // 确保有这个请求头
        },
        body: JSON.stringify({ start, end })  // 确保有发送数据
      })
      .then(res => {
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        return res.json();
      })
      .then(data => {
        if (data.success) {
          drawFlow(data.path);
          animateMaterial(data.path);
        } else {
          alert("未找到路径！");
        }
      })
      .catch(error => {
        console.error("Error:", error);
        alert("请求失败: " + error.message);
      });
    }

  </script>
</body>
</html>
